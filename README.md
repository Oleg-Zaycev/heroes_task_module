      Метод GeneratePreset
Назначение: отвечает за генерацию пресета армии противника.

Ограничения: • суммарная стоимость армии не превышает заданную стоимость; • не более 11 экземпляров каждого типа юнитов. Цель: максимизировать боевую эффективность армии по соотношению «атака / стоимость» и «здоровье / стоимость».

Для реализации используется метод жадного алгоритма.

Описание работы:

Сортировка юнитов по эффективности Юниты сортируются в порядке убывания двух критериев:

Первичный критерий: соотношение атаки к стоимости effAttack=costattack Чем выше значение, тем приоритетнее тип юнита.
Вторичный критерий (при равенстве effAttack): соотношение здоровья к стоимости effHealth=costhealth
Набор армии Для каждого типа юнитов (в порядке сортировки):

Добавляем в армию до 11 экземпляров этого типа.
На каждом шаге проверяем: o не превышен ли лимит в 11 юнитов для этого типа; o хватает ли оставшихся очков (remainingPoints >= unit.getCost()).
Для каждого добавленного юнита: o создаётся копия объекта (чтобы не влиять на исходные данные); o копируются все характеристики (включая бонусные карты).
Возвращается объект Army с заполненными полями: o units — список отобранных юнитов; o points — общая стоимость армии.

Расчёт эффективности алгоритма Сортировка юнитов

Количество типов юнитов: n (обычно невелико, например 4–10).

Сортировка сравнением: O(n log n). Заполнение армии

Для каждого типа юнитов перебирается до 11 экземпляров.

Общее число итераций: O(n × 11) = O(n).

Внутри цикла – константные операции (создание копии, обновление счётчиков). Итоговая сложность: T(n)=O(n log n)+O(n)=O(n log n)

    Метод SuitableForAttackUnitsFinder
Назначение реализует логику определения доступных для атаки юнитов в пошаговой стратегической игре. Метод фильтрует цели атаки с учётом позиции юнитов на поле боя, исключая лишние вычисления поиска пути к недостижимым целям.

Описание работы

Для атаки на левую армию (isLeftArmyTarget = true): Юнит считается доступным, если: o он первый в ряду (нет юнита слева); o слева от него нет живого юнита (!row.get(i − 1).isAlive()).
Для атаки на правую армию (isLeftArmyTarget = false): Юнит считается доступным, если: o он последний в ряду (нет юнита справа); o справа от него нет живого юнита (!row.get(i + 1).isAlive()).
Ключевые особенности: • Пропуск пустых рядов (row.isEmpty()). • Проверка статуса isAlive для учёта только живых юнитов. • Линейный проход по каждому ряду без вложенных циклов.

Расчёт эффективности алгоритма Сложность: O(n), где n — суммарное число юнитов во всех рядах. Обоснование: каждый юнит проверяется ровно один раз.

      Метод getTargetPath
Назначение реализует поиск кратчайшего пути между атакующим и атакуемым юнитом на игровом поле с учётом препятствий (других юнитов). Используется алгоритм поиска в ширину (BFS), поддерживающий движение в 8 направлениях (включая диагонали).

Описание работы

Построение карты препятствий o Создаётся двумерный массив blocked[27][21], где true означает занятую клетку. o Все живые юниты (кроме атакующего и цели) отмечаются как препятствия.
Проверка тривиальных случаев o Если атакующий и цель находятся в одной клетке → возврат пути из одной точки. o Если цель заблокирована → возврат пустого списка.
Поиск пути (BFS) o Используется очередь для обхода в ширину. o Для каждой посещённой клетки сохраняется «родитель» (предыдущая клетка в пути). o Проверяются 8 направлений движения (ортогональные + диагональные). o Обход прерывается при достижении цели.
Восстановление пути o От цели к старту по цепочке «родителей». o Результат разворачивается для получения пути от атакующего к цели.
Расчёт эффективности алгоритма O(W⋅H), где W=27, H=21 (размеры поля). Каждая клетка обрабатывается не более одного раза.

      Метод SimulateBattle
Назначение реализует симуляцию боя между армией игрока и армией компьютера в пошаговой стратегической игре. Обеспечивает: • очерёдность ходов по убыванию силы атаки; • выполнение атак через программы поведения юнитов; • логирование каждого действия; • удаление погибших юнитов из армий; • определение победителя по завершении боя.

Описание работы

Инициализация: Объединение юнитов обеих армий в общий список allUnits.

Основной цикл боя: Цикл выполняется, пока в обеих армиях есть живые юниты. На каждом раунде: Сбор живых юнитов (getLivingUnits). Сортировка по убыванию baseAttack (сильные ходят первыми).

Поочерёдный ход каждого живого юнита: Получение цели через unit.getProgram().attack(). Проверка доступности цели (не null и жива). Выполнение атаки unit.attack(target). Логирование действия через printBattleLog.printBattleLog(). Проверка смерти цели и удаление из армии при необходимости. Пауза Thread.sleep(500) для визуализации хода.

Завершение боя: Проверка выживших в армиях. Вывод сообщения о победителе.

Расчёт эффективности алгоритма O(r⋅u⋅logu) где: • r — количество раундов боя; • u — суммарное число юнитов (u=∣playerArmy∣+∣computerArmy∣).

Поэтапный разбор: • Сбор живых юнитов: (getLivingUnits): O(u) на раунд. • Сортировка по атаке: (Collections.sort): O(u⋅logu) на раунд. • Обход юнитов и атаки: O(u) на раунд (каждая атака — O(1)). • Проверка и удаление погибших: O(1) на атаку. • Общее число раундов: r (зависит от здоровья и урона юнитов). Итоговая сложность: r⋅(O(u)+O(ulogu)+O(u))=O(r⋅ulogu)